# generational, basic evolutionary mechanisms, selection mechanisms...

parent.0 = ../simple/simple.params

#define type
gp.type.a.size = 2
gp.type.a.0.name = double
gp.type.a.1.name = boolean
gp.tc.0.returns = double
gp.tc.1.returns = boolean

# define node contraints

gp.nc.size = 5

gp.nc.0 = ec.gp.GPNodeConstraints
gp.nc.0.name = nc0
gp.nc.0.returns = double
gp.nc.0.size = 0

gp.nc.1 = ec.gp.GPNodeConstraints
gp.nc.1.name = nc1
gp.nc.1.returns = double
gp.nc.1.size = 1
gp.nc.1.child.0 = double

gp.nc.2 = ec.gp.GPNodeConstraints
gp.nc.2.name = nc2
gp.nc.2.returns = double
gp.nc.2.size = 2
gp.nc.2.child.0 = double
gp.nc.2.child.1 = double

gp.nc.3 = ec.gp.GPNodeConstraints
gp.nc.3.name = nc3
gp.nc.3.returns = boolean
gp.nc.3.size = 2
gp.nc.3.child.0 = double
gp.nc.3.child.1 = double

gp.nc.4 = ec.gp.GPNodeConstraints
gp.nc.4.name = nc4
gp.nc.4.returns = double
gp.nc.4.size = 3
gp.nc.4.child.0 = boolean
gp.nc.4.child.1 = double
gp.nc.4.child.2 = double

# We have one function set, of class GPFunctionSet
gp.fs.size = 1
gp.fs.0 = ec.gp.GPFunctionSet
gp.fs.0.name = f0


#Terminals
gp.fs.0.size = 30

#standar functions
gp.fs.0.func.0 = ec.app.func.Add
gp.fs.0.func.0.nc = nc2
gp.fs.0.func.1 = ec.app.func.Cos
gp.fs.0.func.1.nc = nc1
gp.fs.0.func.2 = ec.app.func.Cube
gp.fs.0.func.2.nc = nc1
gp.fs.0.func.3 = ec.app.func.Div
gp.fs.0.func.3.nc = nc2
gp.fs.0.func.4 = ec.app.func.Exp
gp.fs.0.func.4.nc = nc1
gp.fs.0.func.5 = ec.app.func.Log
gp.fs.0.func.5.nc = nc1
gp.fs.0.func.6 = ec.app.func.Mul
gp.fs.0.func.6.nc = nc2
gp.fs.0.func.7 = ec.app.func.Neg
gp.fs.0.func.7.nc = nc1
gp.fs.0.func.8 = ec.app.func.Sin
gp.fs.0.func.8.nc = nc1
gp.fs.0.func.9 = ec.app.func.Sqrt
gp.fs.0.func.9.nc = nc1
gp.fs.0.func.10 = ec.app.func.Square
gp.fs.0.func.10.nc = nc1
gp.fs.0.func.11 = ec.app.func.Sub
gp.fs.0.func.11.nc = nc2
gp.fs.0.func.12 = ec.app.func.Tan
gp.fs.0.func.12.nc = nc1
gp.fs.0.func.13 = ec.app.func.Less
gp.fs.0.func.13.nc = nc3
gp.fs.0.func.14 = ec.app.func.Great
gp.fs.0.func.14.nc = nc3
gp.fs.0.func.15 = ec.app.func.Min
gp.fs.0.func.15.nc = nc2
gp.fs.0.func.16 = ec.app.func.Max
gp.fs.0.func.16.nc = nc2
gp.fs.0.func.17 = ec.app.func.If
gp.fs.0.func.17.nc = nc4

#ephemeral constant
gp.fs.0.func.18 = ec.app.func.RegERC
gp.fs.0.func.18.nc = nc0

#symreg functions
gp.fs.0.func.19 = ec.app.func.syreg.AL
gp.fs.0.func.19.nc = nc0
gp.fs.0.func.20 = ec.app.func.syreg.CA
gp.fs.0.func.20.nc = nc0
gp.fs.0.func.21 = ec.app.func.syreg.CH
gp.fs.0.func.21.nc = nc0
gp.fs.0.func.22 = ec.app.func.syreg.DE
gp.fs.0.func.22.nc = nc0
gp.fs.0.func.23 = ec.app.func.syreg.FA
gp.fs.0.func.23.nc = nc0
gp.fs.0.func.24 = ec.app.func.syreg.FSD
gp.fs.0.func.24.nc = nc0
gp.fs.0.func.25 = ec.app.func.syreg.PH
gp.fs.0.func.25.nc = nc0
gp.fs.0.func.26 = ec.app.func.syreg.RS
gp.fs.0.func.26.nc = nc0
gp.fs.0.func.27 = ec.app.func.syreg.SU
gp.fs.0.func.27.nc = nc0
gp.fs.0.func.28 = ec.app.func.syreg.TSD
gp.fs.0.func.28.nc = nc0
gp.fs.0.func.29 = ec.app.func.syreg.VA
gp.fs.0.func.29.nc = nc0

stat.file = stat/syreg-best.stat
stat.num-children = 1
stat.child.0 = ec.gp.koza.KozaShortStatistics
stat.child.0.file = stat/syreg-gen.stat

eval.problem = ec.app.SyRegProblem
eval.problem.data = ec.app.ProjectData

eval.problem.datafile = data/wine_quality_red.txt
eval.problem.samplesize = 300

eval.problem.testingfile = stat/syreg-test.stat

select.tournament.size = 4

generations = 200

breed.elite.0=1

# silent = true

evalthreads = 6
breedthreads = 6
seed.0 = time
seed.1 = time
seed.2 = time
seed.3 = time
seed.4 = time
seed.5 = time

jobs = 1


#####################################
# Below is the copied koza params	#
# I have removed most of whats been #
# changed above						#
#####################################

# Koza-style fitness metrics
pop.subpop.0.species.fitness = ec.gp.koza.KozaFitness

# GP specific initializer
init = ec.gp.GPInitializer


# EXCHANGER
exch = ec.exchange.InterPopulationExchange
exch.select = ec.select.TournamentSelection
exch.select-to-die = ec.select.RandomSelection

# Number to send
exch.size = 5

# generation to begin at
exch.start = 1

#interval
exch.mod = 8

#fuck
exch.subpop.0.num-dest = 1
exch.subpop.0.dest.0 = 1

exch.subpop.1.num-dest = 1
exch.subpop.1.dest.0 = 2

exch.subpop.2.num-dest = 1
exch.subpop.2.dest.0 = 3

exch.subpop.3.num-dest = 1
exch.subpop.3.dest.0 = 0



#################################
# POPULATION PARAMS


pop.subpops = 4
pop.default-subpop = 0

pop.subpop.0.size = 50
pop.subpop.0.species.pipe.tries = 5
pop.subpop.0.species.pipe.maxdepth = 17
pop.subpop.0.species.pipe.toss = false

pop.subpop.0.species = ec.gp.GPSpecies
pop.subpop.0.species.ind = ec.gp.GPIndividual

# Retry 100 times for duplicates
pop.subpop.0.duplicate-retries = 100

# That GPIndividual has a single tree
pop.subpop.0.species.ind.numtrees = 1
pop.subpop.0.species.ind.tree.0 = ec.gp.GPTree
pop.subpop.0.species.ind.tree.0.tc = tc0

# The GPSpecies has 1 pipeline Crossover 
# MultiBreeding to make 1 or 2 indivs
pop.subpop.0.species.pipe = ec.breed.MultiBreedingPipeline

# IDK what this does
pop.subpop.0.species.pipe.generate-max = false

# Subsidiary pipelines:
pop.subpop.0.species.pipe.num-sources = 1
pop.subpop.0.species.pipe.source.0 = ec.gp.koza.CrossoverPipeline
pop.subpop.0.species.pipe.source.0.prob = 0.9



# POPULATION PARAMS
#################################

# Crossover will use Tournament Selection, try 5 times
# time, have a max depth of 17, and use KozaNodeSelector
gp.koza.xover.prob = 0.8
gp.koza.xover.tries = 5
gp.koza.xover.source.0 = ec.select.TournamentSelection
gp.koza.xover.source.1 = same
gp.koza.xover.ns.0 = ec.gp.koza.KozaNodeSelector
gp.koza.xover.ns.1 = same
gp.koza.xover.maxdepth = 17


# Try 5 times
# Max depth of 17
# Also, Point Mutation uses a GrowBuilder
# by default, with a default of min-depth=max-depth=5
gp.koza.mutate.prob = 0.2
gp.koza.mutate.source.0 = ec.select.TournamentSelection
gp.koza.mutate.ns.0 = ec.gp.koza.KozaNodeSelector
gp.koza.mutate.build.0 = ec.gp.koza.GrowBuilder
gp.koza.mutate.maxdepth = 17
gp.koza.mutate.tries = 5




#
# The default tournament size for TournamentSelection is 7
#

select.tournament.size = 7




# Since GROW is only used for subtree mutation, ECJ uses
# the Koza-standard subtree mutation GROW values for the
# default for GROW as a whole.  This default is
# min-depth=max-depth=5, which I don't like very much,
# but hey, that's the standard.  
# This means that if someone decided to use GROW to generate
# new individual trees, it's also use the defaults below
# unless he overrided them locally.
gp.koza.grow.min-depth = 5
gp.koza.grow.max-depth = 5


#
# We specify a few things about ADFs  -- what kind 
# of stack they use, and what kind of context
#

gp.problem.stack = ec.gp.ADFStack
gp.adf-stack.context = ec.gp.ADFContext

# 
# Here we define the default values for KozaNodeSelection;
# The default is 10% terminals, 90% nonterminals when possible,
# 0% "always pick the root", 0% "pick any node"

gp.koza.ns.terminals = 0.1
gp.koza.ns.nonterminals = 0.9
gp.koza.ns.root = 0.0


# Here we define a single atomic type, "nil", which everyone will use.
# There are no set types defined.

gp.type.a.size = 1
gp.type.a.0.name = nil
gp.type.s.size = 0

# Here we define one GPTreeConstraints object, "tc0",
# which uses ec.gp.koza.HalfBuilder to create nodes,
# only allows nodes from the GPFunctionSet "fset",
# and has the single type "nil" as its tree type.
# You don't need to include the class declaration here,
# but it quiets warnings.

gp.tc.size = 1
gp.tc.0 = ec.gp.GPTreeConstraints
gp.tc.0.name = tc0
gp.tc.0.fset = f0
gp.tc.0.returns = nil


# HalfBuilder will pick GROW half the time and FULL
# the other half, with a ramp from 2 to 6 inclusive.
# By ramp we mean that it first picks a random number between
# 2 and 6 inclusive.  This then becomes the *maximum* tree size
# (for the FULL approach, it's the tree size of the tree, for
# GROW, the tree can get no bigger than this)

gp.tc.0.init = ec.gp.koza.HalfBuilder

# We set the default for HalfBuilder to be a ramp of 2--6,
# with a grow probability of 0.5
gp.koza.half.min-depth = 2
gp.koza.half.max-depth = 6
gp.koza.half.growp = 0.5



